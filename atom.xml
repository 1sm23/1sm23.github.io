<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>1sm23</title>
  
  <subtitle>一块外置脑容量</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.1sm23.com/"/>
  <updated>2021-08-01T09:11:29.321Z</updated>
  <id>https://www.1sm23.com/</id>
  
  <author>
    <name>lsm</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TypeScript关键字 is</title>
    <link href="https://www.1sm23.com/2021/06/02/TypeScript%E5%85%B3%E9%94%AE%E5%AD%97-is/"/>
    <id>https://www.1sm23.com/2021/06/02/TypeScript%E5%85%B3%E9%94%AE%E5%AD%97-is/</id>
    <published>2021-06-02T12:48:37.000Z</published>
    <updated>2021-08-01T09:11:29.321Z</updated>
    
    <content type="html"><![CDATA[<p>可以先去看一下<a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates">官方定义的例子</a>。</p><!-- language: typescript --><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">test: <span class="built_in">any</span></span>): <span class="title">test</span> <span class="title">is</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> test === <span class="string">&quot;string&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">foo: <span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="title">if</span>(<span class="params">isString(foo)</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;it is a string&quot;</span> + foo);</span><br><span class="line"><span class="built_in">console</span>.log(foo.length); <span class="comment">// string function</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">example(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure><p>使用上述格式的类型预测 <code>test is string</code> （而不是定义返回类型为 <code>boolean</code>）在 <code>isString()</code> 被调用后，如果函数返回 <code>true</code>, <strong>TypeScript将在调用该函数的任何块级作用域中将类型缩小为string。</strong>编译器会认为 <code>foo</code> 是该作用域中的 <code>string</code> 类型（并且只在该作用域中）。</p><p>上述 <code>isString</code> 被称为 <code>Type Guard</code> 函数，其中返回必须使用 <code>test is string</code>称为 <code>Type Predicate</code>限制。</p><a id="more"></a><!-- language: typescript --><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;it is a string&quot;</span> + foo);</span><br><span class="line"><span class="built_in">console</span>.log(foo.length); <span class="comment">// string function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型断言只在编译时起作用，编译结果的 <code>.js</code> 文件（运行时）没有任何区别，因为没有考虑到类型。</p><p>我将在下面的四个示例中说明它们之间的差异。</p><p>示例1: </p><p>上面的示例代码不会有编译错误和运行错误。</p><p>示例2: </p><p>下面的示例会有编译错误（同时会运行报错），因为 TypeScript 已经把类型缩小到了 <code>string</code> 并且检查到 <code>string</code> 类型上没有 <code>isInteger</code> 方法。</p><!-- language: typescript --><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">foo: <span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="title">if</span>(<span class="params">isString(foo)</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;it is a string&quot;</span> + foo);</span><br><span class="line"><span class="built_in">console</span>.log(foo.length);</span><br><span class="line"><span class="built_in">console</span>.log(foo.isInteger());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例3: </p><p>下面的代码不会有编译错误但是在运行时报错，因为 TypeScript 只会在作用域里限制类型为 <code>string</code> ，所以  <code>foo.isInteger</code> 会报错（TypeScript 不知道它是一个 <code>string</code> 类型），然而在运行时，<code>string</code> 类型没有 <code>isInteger</code> 方法，所以有运行时错误。</p><!-- language: typescript --><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">foo: <span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="title">if</span>(<span class="params">isString(foo)</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;it is a string&quot;</span> + foo);</span><br><span class="line"><span class="built_in">console</span>.log(foo.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(foo.isInteger());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例4: </p><p>如果不用 <code>test is string</code> （类型预测），TypeScript不会缩小作用域里的类型，下面的示例代码不会有编译错误，但会有运行时错误。</p><!-- language: typescript --><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">test: <span class="built_in">any</span></span>): <span class="title">boolean</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">typeof</span> test === <span class="string">&quot;string&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">foo: <span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="title">if</span>(<span class="params">isString(foo)</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;it is a string&quot;</span> + foo);</span><br><span class="line"><span class="built_in">console</span>.log(foo.length);</span><br><span class="line"><span class="built_in">console</span>.log(foo.isInteger(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论就是 <code>test is string</code> （类型预测）用来在编译时告诉开发者代码是否会有运行时错误。对于 JavaScript 来说，开发者在编译时不会知道是否有错误。这就是 TypeScript 的优势。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可以先去看一下&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates&quot;&gt;官方定义的例子&lt;/a&gt;。&lt;/p&gt;
&lt;!-- language: typescript --&gt;

&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isString&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;test: &lt;span class=&quot;built_in&quot;&gt;any&lt;/span&gt;&lt;/span&gt;): &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; test === &lt;span class=&quot;string&quot;&gt;&amp;quot;string&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;example&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;foo: &lt;span class=&quot;built_in&quot;&gt;any&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;isString(foo)&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&amp;quot;it is a string&amp;quot;&lt;/span&gt; + foo);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(foo.length); &lt;span class=&quot;comment&quot;&gt;// string function&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;example(&lt;span class=&quot;string&quot;&gt;&amp;quot;hello world&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;使用上述格式的类型预测 &lt;code&gt;test is string&lt;/code&gt; （而不是定义返回类型为 &lt;code&gt;boolean&lt;/code&gt;）在 &lt;code&gt;isString()&lt;/code&gt; 被调用后，如果函数返回 &lt;code&gt;true&lt;/code&gt;, &lt;strong&gt;TypeScript将在调用该函数的任何块级作用域中将类型缩小为string。&lt;/strong&gt;编译器会认为 &lt;code&gt;foo&lt;/code&gt; 是该作用域中的 &lt;code&gt;string&lt;/code&gt; 类型（并且只在该作用域中）。&lt;/p&gt;
&lt;p&gt;上述 &lt;code&gt;isString&lt;/code&gt; 被称为 &lt;code&gt;Type Guard&lt;/code&gt; 函数，其中返回必须使用 &lt;code&gt;test is string&lt;/code&gt;称为 &lt;code&gt;Type Predicate&lt;/code&gt;限制。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="TypeScript" scheme="https://www.1sm23.com/tags/TypeScript/"/>
    
      <category term="TypeScript keyword" scheme="https://www.1sm23.com/tags/TypeScript-keyword/"/>
    
      <category term="is" scheme="https://www.1sm23.com/tags/is/"/>
    
  </entry>
  
  <entry>
    <title>Undefined undefined 和 Null null</title>
    <link href="https://www.1sm23.com/2021/03/12/Undefined-undefined-%E5%92%8C-Null-null/"/>
    <id>https://www.1sm23.com/2021/03/12/Undefined-undefined-%E5%92%8C-Null-null/</id>
    <published>2021-03-12T04:36:03.000Z</published>
    <updated>2021-08-01T09:11:29.321Z</updated>
    
    <content type="html"><![CDATA[<p>根据最新的ECMAscript标准，JavaScript里有9种类型：</p><ul><li><p>其中6种可以通过<code>typeof</code>来检测的原始类型（Primitive）</p><ul><li>undefined</li><li>Boolean</li><li>Number</li><li>String</li><li>BigInt</li><li>Symbol</li></ul><a id="more"></a></li><li><p>结构化类型（Structural Types）</p><ul><li>Object</li><li>Function</li></ul></li><li><p>结构化根原始类型（Structural Root Primitive）</p><ul><li>null 特殊的原始类型，其值有额外的用途:如果对象不被继承，则显示null。</li></ul></li></ul><p>其中在面试中被考察到最多的就是 undefined 和 null 的区别。根据 mdn 定义，刚声明的变量和没有值的形式参数会被分配一个 undefined。而 null 虽然在JavaScript中也是一个原始值（primitive），所有的对象都由他派生（derive）而来，在使用<code>typeof</code>操作符会返回<code>object</code>。</p><blockquote><p>typeof null === ‘object’     //  true</p></blockquote><p>所以，他们的</p><h4 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h4><ol><li>都是原始类型。</li><li>都只有一个值，undefined 为 undefined ，null 为 null。</li></ol><h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h4><ol><li>含义完全不同</li><li>undefined 可以使用<code>typeof</code>检测，而 null 不能。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据最新的ECMAscript标准，JavaScript里有9种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;其中6种可以通过&lt;code&gt;typeof&lt;/code&gt;来检测的原始类型（Primitive）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;undefined&lt;/li&gt;
&lt;li&gt;Boolean&lt;/li&gt;
&lt;li&gt;Number&lt;/li&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;BigInt&lt;/li&gt;
&lt;li&gt;Symbol&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="javascript" scheme="https://www.1sm23.com/tags/javascript/"/>
    
      <category term="JavaScript数据类型" scheme="https://www.1sm23.com/tags/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>我的常用css样式</title>
    <link href="https://www.1sm23.com/2020/11/02/%E6%88%91%E7%9A%84%E5%B8%B8%E7%94%A8css%E6%A0%B7%E5%BC%8F/"/>
    <id>https://www.1sm23.com/2020/11/02/%E6%88%91%E7%9A%84%E5%B8%B8%E7%94%A8css%E6%A0%B7%E5%BC%8F/</id>
    <published>2020-11-02T03:14:07.000Z</published>
    <updated>2021-08-01T09:11:29.328Z</updated>
    
    <content type="html"><![CDATA[<p>因为在工程里频繁用到flex布局，所以写了一套常用的flex样式组合</p><a id="more"></a><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.row</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:-webkit-box;</span><br><span class="line">    <span class="attribute">display</span>:-ms-flexbox;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">-webkit-box-orient</span>: horizontal;</span><br><span class="line">    <span class="attribute">-webkit-box-direction</span>: normal;</span><br><span class="line">    <span class="attribute">-ms-flex-direction</span>: row;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.column</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">    <span class="attribute">display</span>: -ms-flexbox;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">-webkit-box-orient</span>: vertical;</span><br><span class="line">    <span class="attribute">-webkit-box-direction</span>: normal;</span><br><span class="line">    <span class="attribute">-ms-flex-direction</span>: column;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 主轴 */</span></span><br><span class="line"><span class="selector-class">.justify-between</span>&#123;</span><br><span class="line">    <span class="attribute">-webkit-box-pack</span>: justify;</span><br><span class="line">    <span class="attribute">-ms-flex-pack</span>: justify;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.justify-center</span>&#123;</span><br><span class="line">    <span class="attribute">-webkit-box-pack</span>: center;</span><br><span class="line">    <span class="attribute">-ms-flex-pack</span>: center;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.justify-around</span>&#123;</span><br><span class="line">    <span class="attribute">-ms-flex-pack</span>: distribute;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 交叉轴 */</span></span><br><span class="line"><span class="selector-class">.item-center</span>&#123;</span><br><span class="line">    <span class="attribute">-webkit-box-align</span>: center;</span><br><span class="line">    <span class="attribute">-ms-flex-align</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-start</span>&#123;</span><br><span class="line">    <span class="attribute">-webkit-box-align</span>: start;</span><br><span class="line">    <span class="attribute">-ms-flex-align</span>: start;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-end</span>&#123;</span><br><span class="line">    <span class="attribute">-webkit-box-align</span>: end;</span><br><span class="line">    <span class="attribute">-ms-flex-align</span>: end;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.grow</span>&#123;</span><br><span class="line">    <span class="attribute">-webkit-box-flex</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">-ms-flex-positive</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.shrink</span>&#123;</span><br><span class="line">    <span class="attribute">-ms-flex-negative</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不换行 */</span></span><br><span class="line"><span class="selector-class">.no-wrap</span>&#123;</span><br><span class="line">    <span class="attribute">-ms-flex-wrap</span>: nowrap;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这套样式使用<code>gulp-autoprefixer</code>处理兼容问题，工程在<a href="https://github.com/1sm23/flex-layout.git">flex-layout</a><br>浏览器兼容为</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;browserslist&quot;: [</span><br><span class="line">    &quot;&gt; 1%&quot;,</span><br><span class="line">    &quot;last 2 versions&quot;,</span><br><span class="line">    <span class="string">&quot;not ie &lt;= 8&quot;</span></span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>其他css重制可以使用<a href="https://necolas.github.io/normalize.css/">Normalize.css</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为在工程里频繁用到flex布局，所以写了一套常用的flex样式组合&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="css" scheme="https://www.1sm23.com/tags/css/"/>
    
      <category term="flex layout" scheme="https://www.1sm23.com/tags/flex-layout/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript闭包</title>
    <link href="https://www.1sm23.com/2020/09/04/JavaScript%E9%97%AD%E5%8C%85/"/>
    <id>https://www.1sm23.com/2020/09/04/JavaScript%E9%97%AD%E5%8C%85/</id>
    <published>2020-09-04T12:11:40.000Z</published>
    <updated>2021-08-01T09:11:29.320Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h3><p>闭包是在外部函数返回后仍能访问其外部函数作用域的函数。这意味着闭包可以记住并访问外部函数的变量和参数，即使函数已经返回。</p><p>在深入研究闭包之前，让我们先了解词法作用域。</p><a id="more"></a><h4 id="什么是词法作用域？"><a href="#什么是词法作用域？" class="headerlink" title="什么是词法作用域？"></a>什么是词法作用域？</h4><p>JavaScript中的词法作用域或静态作用域指的是根据变量、函数和对象在源代码中的位置来访问它们。例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="string">&#x27;outer&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> c = <span class="string">&#x27;inner&#x27;</span></span><br><span class="line">      <span class="built_in">console</span>.log(c);   <span class="comment">// prints &#x27;inner&#x27;</span></span><br><span class="line">      <span class="built_in">console</span>.log(b);   <span class="comment">// prints &#x27;outer&#x27;</span></span><br><span class="line">      <span class="built_in">console</span>.log(a);   <span class="comment">// prints &#x27;global&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a);     <span class="comment">// prints &#x27;global&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(b);     <span class="comment">// prints &#x27;outer&#x27;</span></span><br><span class="line">    inner();</span><br><span class="line">  &#125;</span><br><span class="line">outer();</span><br><span class="line"><span class="built_in">console</span>.log(a);         <span class="comment">// prints &#x27;global&#x27;</span></span><br></pre></td></tr></table></figure><p><code>inner</code>函数可以访问定义在他自己的作用域、<code>outer</code>函数作用域、全局作用域中定义的变量。<code>outer</code>函数可以访问在其自身作用域和全局作用域中定义的变量</p><h3 id="闭包栗子"><a href="#闭包栗子" class="headerlink" title="闭包栗子"></a>闭包栗子</h3><h4 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;Peter&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> peter = person();</span><br><span class="line">peter(); <span class="comment">// prints &#x27;Peter&#x27;</span></span><br></pre></td></tr></table></figure><p>在这段代码里，我们调用 <code>person</code> 函数返回了一个内部函数 <code>displayName</code> 并将该内部函数存储在 <code>peter</code> 变量中，当我们调用 <code>peter</code>函数（实际上是引用了 <code>displayName</code> 函数），控制台打印出了 ‘Peter’。</p><p>但是 <code>displayName</code> 函数里没有叫做 <code>name</code> 的变量，所以这个函数可以以某种方式访问它的外部函数 <code>person</code> 甚至是在它已经执行完之后。所以这个 <code>displayName</code> 函数实际上就是一个闭包。</p><h4 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> counter++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> count = getCounter();</span><br><span class="line"><span class="built_in">console</span>.log(count());  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(count());  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(count());  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>这次我们把通过 <code>getCounter</code> 返回的匿名函数赋值给 <code>count</code> 变量，因为 <code>count</code> 函数现在是一个闭包，它能在 <code>getCounter</code> 函数返回之后访问到 <code>getCounter</code> 函数内的 <code>counter</code> 变量。</p><p>但是⚠️注意，每个 <code>count</code> 函数返回的 <code>counter</code> 的值并没有按照期望重置到 <code>0</code>。</p><p>那是因为，每次调用 <code>count</code> 函数，一个新的该函数的作用域被创建，但是 <code>getCounter</code> 函数只创建了一个作用域，因为 <code>counter</code> 变量是在 <code>getCounter()</code> 的作用域中定义的，所以它将在每次 <code>count</code> 函数调用时递增，而不是重置为 <code>0</code>。</p><h3 id="工作原理？"><a href="#工作原理？" class="headerlink" title="工作原理？"></a>工作原理？</h3><p>到目前为止，我们知道了闭包是什么还有了解了几个例子，现在我们来探索JavaScript里的闭包到底是如何工作的。</p><p>要真正理解闭包，我们必须立即JavaScript里的两个重要概念，1. 执行上下文 2. 词法环境</p><h4 id="执行上下文（Execution-Context）"><a href="#执行上下文（Execution-Context）" class="headerlink" title="执行上下文（Execution Context）"></a>执行上下文（Execution Context）</h4><p>执行上下文是一个当JavaScript被解释执行的时候的一个抽象环境。当全局代码被执行时，他是在全局执行上下文中被执行，当函数被调用时是在函数执行上下文中。</p><p>只能有一个运行的执行上下文（因为JavaScript是单线程），它由称为执行栈或调用栈的堆栈数据结构管理。</p><p>执行栈是一个采用后进先出的栈，其中items只能从栈顶部添加或者删除。</p><p>正在执行的上下文永远是在栈的顶部，当函数运行完之后，它的执行栈会被pop出来，接着执行它下面的执行上下文。</p><p>看一下这个代码片段来更好理解执行上下文和栈：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gig7x7ngn0j30zm0l00w3.jpg" alt=""></p><p>当这段代码被执行时，JavaScript引擎创建一个全局执行上下文来执行全局代码，当遇到 <code>first()</code> 函数的调用时，它创建一个新的函数执行上下文并把这个上下文压入栈中</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gig813iluxj303c02i74a.gif" alt=""></p><p>所以上面代码的执行栈会像是这样：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gig82c1w7rj30uk06oaau.jpg" alt=""></p><p>当 <code>first()</code> 函数调用完后，它的执行上下文被移出栈，调用栈的当前栈来到它下面的栈也就是全局执行上下文，所以剩下的全局作用域的代码将会被执行。</p><h4 id="词法环境（Lexical-Environment）"><a href="#词法环境（Lexical-Environment）" class="headerlink" title="词法环境（Lexical Environment）"></a>词法环境（Lexical Environment）</h4><p>每当JavaScript引擎创建一个执行上下文来执行函数或全局代码时，它还创建一个新的词法环境来存储在该函数执行期间在该函数中定义的变量。</p><p>词汇环境是保存标识符变量映射的数据结构。 （这里的标识符是指变量/函数的名称，而变量是对实际对象[包括函数类型对象]或原始值的引用）。</p><p>词汇环境有两个组成部分:(1)<strong>环境记录</strong>和(2)<strong>对外部环境的引用</strong>。</p><ol><li><strong>环境记录</strong>是变量和函数声明被存储的特定地点</li><li><strong>对外部环境的引用</strong>意味着它可以访问到外部（父级）的词法环境，要弄懂闭包是怎么运作的，必须弄懂这个部分。</li></ol><p>词法环境在概念上是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lexicalEnvironment = &#123;</span><br><span class="line">  environmentRecord: &#123;</span><br><span class="line">    &lt;identifier&gt; : &lt;value&gt;,</span><br><span class="line">    &lt;identifier&gt; : &lt;value&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  outer: &lt; Reference to the parent lexical environment&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们再来看看刚刚的代码片段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">25</span>;  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Inside first function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">first();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Inside global execution context&#x27;</span>);</span><br></pre></td></tr></table></figure><p>当JavaScript引擎创建全局执行上下文来执行全局代码时，它还创建一个新的词法环境来存储在全局作用域中定义的变量和函数。因此全局作用域的词汇环境将是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">globalLexicalEnvironment = &#123;</span><br><span class="line">  environmentRecord: &#123;</span><br><span class="line">      a     : <span class="string">&#x27;Hello World!&#x27;</span>,</span><br><span class="line">      first : &lt; reference to <span class="function"><span class="keyword">function</span> <span class="title">object</span> &gt;</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">  <span class="title">outer</span>: <span class="title">null</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>这里外部词法环境是 <code>null</code> 是因为全局作用域没有外部词法环境。</p><p>当引擎给 <code>first()</code> 函数创建上下文的时候，它也创建了一个词法环境来存储在执行该函数期间定义的变量，所以这个函数的词法环境看起来会像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">functionLexicalEnvironment = &#123;</span><br><span class="line">  environmentRecord: &#123;</span><br><span class="line">      b    : <span class="number">25</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  outer: &lt;globalLexicalEnvironment&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的外部词法环境是全局词法环境是因为这个函数是被全局作用域包裹。</p><p><strong>注意</strong>——当函数执行完成，他的执行上下文会被移出栈，但是它的词法环境可能不会被移出内存！！<strong>这取决于在外部词法环境属性中，函数的词法环境是否被任何其他词法环境引用</strong>。</p><h3 id="剖析闭包例子"><a href="#剖析闭包例子" class="headerlink" title="剖析闭包例子"></a>剖析闭包例子</h3><p>现在我们理解了执行上下文和词法环境，回到闭包。</p><h4 id="例子1-1"><a href="#例子1-1" class="headerlink" title="例子1"></a>例子1</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;Peter&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> peter = person();</span><br><span class="line">peter(); <span class="comment">// prints &#x27;Peter&#x27;</span></span><br></pre></td></tr></table></figure><p>当 <code>person</code> 函数被执行时，JavaScript引擎为这个函数创建了一个执行上下文和词法环境，在函数执行完后，它返回一个 <code>displayName</code>函数并且把它赋值给 <code>peter</code> 变量。</p><p>所以它的词法环境是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">personLexicalEnvironment = &#123;</span><br><span class="line">  environmentRecord: &#123;</span><br><span class="line">    name : <span class="string">&#x27;Peter&#x27;</span>,</span><br><span class="line">    displayName: &lt; displayName <span class="function"><span class="keyword">function</span> <span class="title">reference</span>&gt;</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">  <span class="title">outer</span>: &lt;<span class="title">globalLexicalEnvironment</span>&gt;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>当 <code>person</code> 函数执行完后，它的执行上下文被移出栈，但是他的词法环境依然还在内存里，因为它词法环境被它内部的 <code>displayName</code> 函数的词法环境引用，所以它( <code>person</code> 函数)的变量依然还在内存里。</p><p>当 <code>personLexicalEnvironment</code>被创建，js引擎会把 <code>personLexicalEnvironment</code> 附加到所有在这个词法环境中定义的函数中，所以之后有任何内部函数被调用时，js引擎会把外部词法环境设置成函数定义时附加上的那个。</p><p>当 <code>peter</code> 函数被执行（实际上是 <code>displayName</code> 函数的一个引用），js引擎为它创建了一个新的执行上下文和词法环境。</p><p>所以它的词法环境是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">displayNameLexicalEnvironment = &#123;</span><br><span class="line">  environmentRecord: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  outer: &lt;personLexicalEnvironment&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在 <code>displayName</code> 函数里没有变量，它的环境记录是空的。在这个函数的执行期间，js引擎会在这个函数的词法环境里查找变量 <code>name</code>。</p><p>因为在 <code>displayName</code> 函数的词法环境里没有变量，js引擎会在外部环境查找，也就是仍然存储在内存里的 <code>person</code> 函数的词法环境。js引擎找到变量 <code>name</code> 然后打印在控制台中。</p><h4 id="例子2-1"><a href="#例子2-1" class="headerlink" title="例子2"></a>例子2</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> counter++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> count = getCounter();</span><br><span class="line"><span class="built_in">console</span>.log(count());  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(count());  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(count());  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>同样的，<code>getCounter</code>函数的词法环境：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getCounterLexicalEnvironment = &#123;</span><br><span class="line">  environmentRecord: &#123;</span><br><span class="line">    counter: <span class="number">0</span>,</span><br><span class="line">    &lt;anonymous <span class="function"><span class="keyword">function</span>&gt; : &lt; <span class="title">reference</span> <span class="title">to</span> <span class="function"><span class="keyword">function</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="function"><span class="function">  <span class="title">outer</span>: &lt;<span class="title">globalLexicalEnvironment</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure><p>这个函数返回了一个匿名函数赋值给了 <code>count</code> 变量。</p><p>当 <code>count</code> 函数被执行时，它的词法环境:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">countLexicalEnvironment = &#123;</span><br><span class="line">  environmentRecord: &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  outer: &lt;getCountLexicalEnvironment&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>count</code> 函数被调用，js引擎会在这个函数的词法环境里查找 <code>counter</code> 变量，同样的它的环境记录是空的，引擎会从函数的外部词法环境里查找。</p><p>引擎找到变量，打印在控制台上然后在 <code>getCounter</code> 函数词法环境里自增 <code>counter</code> 变量。</p><p>在第一次调用 <code>count</code> 函数后，<code>getCounter</code>函数的词法环境：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getCounterLexicalEnvironment = &#123;</span><br><span class="line">  environmentRecord: &#123;</span><br><span class="line">    counter: <span class="number">1</span>,</span><br><span class="line">    &lt;anonymous <span class="function"><span class="keyword">function</span>&gt; : &lt; <span class="title">reference</span> <span class="title">to</span> <span class="function"><span class="keyword">function</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="function"><span class="function">  <span class="title">outer</span>: &lt;<span class="title">globalLexicalEnvironment</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure><p>每次调用 <code>count</code> 函数，js引擎创建一个新的 <code>count</code> 函数的词法环境，自增 <code>counter</code> 变量然后更新 <code>getCounter</code> 函数的词法环境。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是闭包？&quot;&gt;&lt;a href=&quot;#什么是闭包？&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包？&quot;&gt;&lt;/a&gt;什么是闭包？&lt;/h3&gt;&lt;p&gt;闭包是在外部函数返回后仍能访问其外部函数作用域的函数。这意味着闭包可以记住并访问外部函数的变量和参数，即使函数已经返回。&lt;/p&gt;
&lt;p&gt;在深入研究闭包之前，让我们先了解词法作用域。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://www.1sm23.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://www.1sm23.com/tags/javascript/"/>
    
      <category term="closure" scheme="https://www.1sm23.com/tags/closure/"/>
    
      <category term="闭包" scheme="https://www.1sm23.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序列表刷新</title>
    <link href="https://www.1sm23.com/2020/07/26/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%97%E8%A1%A8%E5%88%B7%E6%96%B0/"/>
    <id>https://www.1sm23.com/2020/07/26/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%97%E8%A1%A8%E5%88%B7%E6%96%B0/</id>
    <published>2020-07-26T00:11:49.000Z</published>
    <updated>2021-08-01T09:11:29.327Z</updated>
    
    <content type="html"><![CDATA[<p>在微信小程序中时常有列表更新的需求，在这里我列出几种基于下面目录结构的刷新方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── list</span><br><span class="line">└── update</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-获取列表页实例调用列表方法"><a href="#1-获取列表页实例调用列表方法" class="headerlink" title="1.获取列表页实例调用列表方法"></a>1.获取列表页实例调用列表方法</h3><p>更新页中更新成功后使用<code>getCurrentPages()</code>获取当前小程序的页面栈，调用列表页初始化时的方法，实现刷新。</p><p>list/index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  ...get list request</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>update/index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">update().then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prevPage = getCurrentPages()[getCurrentPages().length - <span class="number">2</span>];</span><br><span class="line">  <span class="keyword">await</span> prevPage.getList()</span><br><span class="line">  wx.navigateBack(&#123;</span><br><span class="line">          delta:<span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-更新接口返回成功数据"><a href="#2-更新接口返回成功数据" class="headerlink" title="2.更新接口返回成功数据"></a>2.更新接口返回成功数据</h3><p>在列表add请求并且让后端在add接口成功时返回添加的数据可以直接处理列表。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>减少一次网络请求</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>更新后的列表数据可能不为最新值</li></ul><p>update/index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> prevPage = getCurrentPages()[getCurrentPages().length - <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">const</span> list = prevPage.data.list;</span><br><span class="line">            list.unshift(&#123;</span><br><span class="line">              name: <span class="string">&#x27;1sm&#x27;</span>,</span><br><span class="line">              age:<span class="number">18</span>,</span><br><span class="line">              updateTime: <span class="built_in">Date</span>.now(),</span><br><span class="line">              size: <span class="built_in">this</span>.data.size,</span><br><span class="line">              id: <span class="built_in">this</span>.data.id</span><br><span class="line">            &#125;)</span><br><span class="line">            prevPage.setData(&#123;</span><br><span class="line">              list</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure><h3 id="3-onShow更新列表"><a href="#3-onShow更新列表" class="headerlink" title="3.onShow更新列表"></a>3.onShow更新列表</h3><p>将初始化数据动作写在<code>onShow</code>生命周期函数中，这种处理方法很有效，但在多次需要展示的页面例如tab页中会带来其他的问题，比如每次展示页面时都发起网络请求过于频繁。</p><p>list/index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">onShow</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.getList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-页面间通信接口"><a href="#4-页面间通信接口" class="headerlink" title="4.页面间通信接口"></a>4.页面间通信接口</h3><p><code>events</code>是<code>wx.navigateTo</code>的一个属性，是<a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html">页面间通信接口</a>，用于监听被打开页面发送到当前页面的数据。对我列出的这种目录结构，刷新列表使用这种方式十分简单优雅。</p><p>list/index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">updateItem</span>(<span class="params">event</span>)</span>&#123;  <span class="comment">//点击列表单个项跳转</span></span><br><span class="line">  <span class="keyword">const</span> that = <span class="built_in">this</span>;</span><br><span class="line">  wx.navigateTo(&#123;</span><br><span class="line">    url:<span class="string">`./update/index?id=<span class="subst">$&#123;event.currentTarget.id&#125;</span>`</span>,</span><br><span class="line">    events:&#123; </span><br><span class="line">      <span class="function"><span class="title">updateList</span>(<span class="params"></span>)</span>&#123; <span class="comment">//定义更新列表事件</span></span><br><span class="line">        that.getList();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>update/index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  updateRequest().then(<span class="function">()=&gt;</span>&#123; <span class="comment">//更新请求成功后</span></span><br><span class="line">    <span class="keyword">const</span> ec = <span class="built_in">this</span>.getOpenerEventChannel() <span class="comment">//获取页面间事件通信通道</span></span><br><span class="line">    ec.emit(<span class="string">&#x27;updateList&#x27;</span>);</span><br><span class="line">    wx.navigateBack(&#123;</span><br><span class="line">      delta:<span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在微信小程序中时常有列表更新的需求，在这里我列出几种基于下面目录结构的刷新方式&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── list&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;└── update&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="wxapp" scheme="https://www.1sm23.com/categories/wxapp/"/>
    
    
      <category term="wxapp" scheme="https://www.1sm23.com/tags/wxapp/"/>
    
      <category term="微信小程序" scheme="https://www.1sm23.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="列表刷新" scheme="https://www.1sm23.com/tags/%E5%88%97%E8%A1%A8%E5%88%B7%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>csgo rws是什么？</title>
    <link href="https://www.1sm23.com/2020/04/21/csgo-rws/"/>
    <id>https://www.1sm23.com/2020/04/21/csgo-rws/</id>
    <published>2020-04-21T11:33:01.000Z</published>
    <updated>2021-08-01T09:11:29.322Z</updated>
    
    <content type="html"><![CDATA[<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge1nlvs6bfj310s0rw45o.jpg" style="zoom:33%;" /><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge1nqmyakxj30yn0ovn1f.jpg" style="zoom:33%;" /><p>5e对战平台和esea都采用了<code>RWS</code>值来统计选手的能力，那<code>RWS</code>到底是什么呢？<code>RWS</code>多少才是正常的？为什么我rating很高，<code>RWS</code>却是全队平均水平呢？🤔️</p><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>​        <code>RWS</code>统计数据是<strong>R</strong>ound <strong>W</strong>in <strong>S</strong>hares的缩写，用于表示玩家对团队整体成功的贡献。</p><h3 id="我怎么加RWS"><a href="#我怎么加RWS" class="headerlink" title="我怎么加RWS?"></a>我怎么加RWS?</h3><ul><li><code>RWS</code>值的范围从<code>0</code>到<code>100</code>，数值高的选手表示更厉害，平均<code>RWS</code>是10。</li><li>每回合只有胜利方获得100<code>RWS</code>或者说100胜利贡献。</li><li>输掉回合的队伍没有<code>RWS</code>增加。</li><li>掉线的人每回合都是0<code>RWS</code></li></ul><p>在纯靠击杀完成的回合，100点<code>RWS</code>根据每个人造成的伤害平均分配</p><ul><li>栗子#1：你造成了140伤害，你队伍其余的人总共造成了360伤害，你将得到28.00<code>RWS</code>（140 / 500 * 100)</li></ul><p>在雷包爆炸或者被拆除的回合，完成拆包或者下包的选手将会得到30<code>RWS</code>，剩下的70<code>RWS</code>将根据你们造成的伤害平均分配。</p><ul><li>栗子#2：你下包，包炸了，并且你当前回合造成的伤害是0，你的队友每人造成50伤害，那么你当前回合将得到30<code>RWS</code>，你的队友每人得到17.50<code>RWS</code>（(100-30)/4)</li><li>栗子#3：你拆了雷包，并且造成了100伤害，你的队友每人造成了50点伤害，那么你会得到53.33<code>RWS</code>（其中30是拆包，其余的23.33是根据伤害分配的）</li></ul><p><a href="https://support.esea.net/hc/en-us/articles/360008740634-What-is-RWS-">esea原文链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1ge1nlvs6bfj310s0rw45o.jpg&quot; style=&quot;zoom:33%;&quot; /&gt;

&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1ge1nqmyakxj30yn0ovn1f.jpg&quot; style=&quot;zoom:33%;&quot; /&gt;

&lt;p&gt;5e对战平台和esea都采用了&lt;code&gt;RWS&lt;/code&gt;值来统计选手的能力，那&lt;code&gt;RWS&lt;/code&gt;到底是什么呢？&lt;code&gt;RWS&lt;/code&gt;多少才是正常的？为什么我rating很高，&lt;code&gt;RWS&lt;/code&gt;却是全队平均水平呢？🤔️&lt;/p&gt;
    
    </summary>
    
    
      <category term="闲言碎语" scheme="https://www.1sm23.com/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    
      <category term="csgo" scheme="https://www.1sm23.com/tags/csgo/"/>
    
      <category term="esea" scheme="https://www.1sm23.com/tags/esea/"/>
    
      <category term="steam" scheme="https://www.1sm23.com/tags/steam/"/>
    
      <category term="rws" scheme="https://www.1sm23.com/tags/rws/"/>
    
      <category term="csgodata" scheme="https://www.1sm23.com/tags/csgodata/"/>
    
      <category term="csgo rws是什么" scheme="https://www.1sm23.com/tags/csgo-rws%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序页面上推</title>
    <link href="https://www.1sm23.com/2020/03/30/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%8E%A8/"/>
    <id>https://www.1sm23.com/2020/03/30/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%8E%A8/</id>
    <published>2020-03-30T14:31:17.000Z</published>
    <updated>2021-08-01T09:11:29.328Z</updated>
    
    <content type="html"><![CDATA[<p>微信小程序中的表单输入组件默认上推页面，不符合某些需求，下面是一个解决方案。</p><ol><li>设置表单组件的默认上推页面属性<code>adjust-position=“&#123;&#123;false&#125;&#125;”</code></li><li>表单组件绑定<code>focus</code>事件</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">bindfocus</span>=<span class="string">&quot;focushandler&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">focushandler</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//height为输入框距离页面底部高度</span></span><br><span class="line"><span class="built_in">this</span>.setData(&#123;</span><br><span class="line">    bottom:e.detail.height</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入区域绝对定位</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">bindfocus</span>=<span class="string">&quot;focushandler&quot;</span> <span class="attr">style</span>=<span class="string">&quot;&#123;&#123;bottom?&#x27;position:absolute;bottom:&#x27;+bottom+&#x27;px;&#x27;:&#x27;&#x27;&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;微信小程序中的表单输入组件默认上推页面，不符合某些需求，下面是一个解决方案。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置表单组件的默认上推页面属性&lt;code&gt;adjust-position=“&amp;#123;&amp;#123;false&amp;#125;&amp;#125;”&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="wxapp" scheme="https://www.1sm23.com/categories/wxapp/"/>
    
    
      <category term="wxapp" scheme="https://www.1sm23.com/tags/wxapp/"/>
    
      <category term="微信小程序" scheme="https://www.1sm23.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="wechat" scheme="https://www.1sm23.com/tags/wechat/"/>
    
      <category term="weapp" scheme="https://www.1sm23.com/tags/weapp/"/>
    
  </entry>
  
  <entry>
    <title>提交pull request</title>
    <link href="https://www.1sm23.com/2020/03/22/%E7%AC%AC%E4%B8%80%E4%B8%AApull%20request/"/>
    <id>https://www.1sm23.com/2020/03/22/%E7%AC%AC%E4%B8%80%E4%B8%AApull%20request/</id>
    <published>2020-03-21T17:28:11.000Z</published>
    <updated>2021-08-01T09:11:29.330Z</updated>
    
    <content type="html"><![CDATA[<p>公司有用到腾讯云的<a href="https://github.com/tencentyun/TIC">TIC</a> PasS服务，TIC全称腾讯云互动课堂在线教育解决方案，就是一个白板加上IM功能，在小程序端里其中的白板组件board-component使用起来体验极其不好，画笔垂直绘画的时候很大几率会引起页面滚动，在小程序社区找到解决问题的办法后我有了提pull request的想法。</p><a id="more"></a><p>首先fork一份到自己的仓库</p><p>然后clone自己的fork到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> yourforkrepo</span><br></pre></td></tr></table></figure><p>作出修改后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;&#x27;</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>最后在自己的仓库上方点击Pull request , New pull request，作出评论即可啦</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd22scz3dcj31ex0u0jxd.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司有用到腾讯云的&lt;a href=&quot;https://github.com/tencentyun/TIC&quot;&gt;TIC&lt;/a&gt; PasS服务，TIC全称腾讯云互动课堂在线教育解决方案，就是一个白板加上IM功能，在小程序端里其中的白板组件board-component使用起来体验极其不好，画笔垂直绘画的时候很大几率会引起页面滚动，在小程序社区找到解决问题的办法后我有了提pull request的想法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="https://www.1sm23.com/categories/git/"/>
    
    
      <category term="git" scheme="https://www.1sm23.com/tags/git/"/>
    
      <category term="github" scheme="https://www.1sm23.com/tags/github/"/>
    
      <category term="pull request" scheme="https://www.1sm23.com/tags/pull-request/"/>
    
  </entry>
  
  <entry>
    <title>flex布局换行对齐</title>
    <link href="https://www.1sm23.com/2020/03/21/flex%E5%B8%83%E5%B1%80%E6%8D%A2%E8%A1%8C%E5%AF%B9%E9%BD%90/"/>
    <id>https://www.1sm23.com/2020/03/21/flex%E5%B8%83%E5%B1%80%E6%8D%A2%E8%A1%8C%E5%AF%B9%E9%BD%90/</id>
    <published>2020-03-21T00:47:18.000Z</published>
    <updated>2021-08-01T09:11:29.323Z</updated>
    
    <content type="html"><![CDATA[<h5 id="列表每行数量相同"><a href="#列表每行数量相同" class="headerlink" title="列表每行数量相同"></a>列表每行数量相同</h5><p><a href="https://www.zhangxinxu.com/wordpress/2019/08/css-flex-last-align/">张鑫旭原文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;列表每行数量相同&quot;&gt;&lt;a href=&quot;#列表每行数量相同&quot; class=&quot;headerlink&quot; title=&quot;列表每行数量相同&quot;&gt;&lt;/a&gt;列表每行数量相同&lt;/h5&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhangxinxu.com/wordpress/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>安装 mlocate</title>
    <link href="https://www.1sm23.com/2019/09/20/linux-%E5%AE%89%E8%A3%85-mlocate/"/>
    <id>https://www.1sm23.com/2019/09/20/linux-%E5%AE%89%E8%A3%85-mlocate/</id>
    <published>2019-09-20T13:45:48.000Z</published>
    <updated>2021-08-01T09:11:29.324Z</updated>
    
    <content type="html"><![CDATA[<p>linux查找软件，速度快，好用👌</p><p>安装步骤</p><ol><li><p>安装mlocate</p><p>Linux </p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install mlocate</span><br></pre></td></tr></table></figure><p>​        Mac</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install mlocate</span><br></pre></td></tr></table></figure><ol start="2"><li><p>更新数据库</p><p>Linux </p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updatedb</span><br></pre></td></tr></table></figure><p>​        Mac</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/libexec/locate.updatedb </span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;linux查找软件，速度快，好用👌&lt;/p&gt;
&lt;p&gt;安装步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装mlocate&lt;/p&gt;
&lt;p&gt;Linux &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
      <category term="linux" scheme="https://www.1sm23.com/categories/linux/"/>
    
    
      <category term="linux" scheme="https://www.1sm23.com/tags/linux/"/>
    
      <category term="mlocate" scheme="https://www.1sm23.com/tags/mlocate/"/>
    
      <category term="linux app" scheme="https://www.1sm23.com/tags/linux-app/"/>
    
  </entry>
  
  <entry>
    <title>.gitignore规则不生效</title>
    <link href="https://www.1sm23.com/2019/09/19/gitignore%E8%A7%84%E5%88%99%E4%B8%8D%E7%94%9F%E6%95%88/"/>
    <id>https://www.1sm23.com/2019/09/19/gitignore%E8%A7%84%E5%88%99%E4%B8%8D%E7%94%9F%E6%95%88/</id>
    <published>2019-09-19T09:49:19.000Z</published>
    <updated>2021-08-01T09:11:29.323Z</updated>
    
    <content type="html"><![CDATA[<p>.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。<br>解决方法就是先把本地缓存删除（改变成未track状态），然后再提交:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m &#39;update .gitignore&#39;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。&lt;br&gt;解决方法就是先把本地缓存删除（改变成未track状态），然后再提交:&lt;/p&gt;
&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
    
      <category term="git" scheme="https://www.1sm23.com/categories/git/"/>
    
    
      <category term="git" scheme="https://www.1sm23.com/tags/git/"/>
    
      <category term="gitignore" scheme="https://www.1sm23.com/tags/gitignore/"/>
    
      <category term="git不生效" scheme="https://www.1sm23.com/tags/git%E4%B8%8D%E7%94%9F%E6%95%88/"/>
    
  </entry>
  
  <entry>
    <title>new到底干了什么？</title>
    <link href="https://www.1sm23.com/2018/12/05/new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%88%B0%E5%BA%95%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>https://www.1sm23.com/2018/12/05/new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%88%B0%E5%BA%95%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2018-12-05T04:56:13.000Z</published>
    <updated>2021-08-01T09:11:29.325Z</updated>
    
    <content type="html"><![CDATA[<ol><li>创建一个空的简单JavaScript对象（即<code>&#123;&#125;</code>）；</li><li>链接该对象（设置该对象的<strong>constructor</strong>）到另一个对象 ；</li><li>将步骤1新创建的对象作为<code>this</code>的上下文 ；</li><li>如果该函数没有返回对象，则返回<code>this</code>。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;创建一个空的简单JavaScript对象（即&lt;code&gt;&amp;#123;&amp;#125;&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;链接该对象（设置该对象的&lt;strong&gt;constructor&lt;/strong&gt;）到另一个对象 ；&lt;/li&gt;
&lt;li&gt;将步骤1新创建的对象作为&lt;
      
    
    </summary>
    
    
    
      <category term="javascript" scheme="https://www.1sm23.com/tags/javascript/"/>
    
  </entry>
  
</feed>
